{% extends "sorting/base_sorting.html" %}

{% block breadcrumb_name %}Insertion Sort{% endblock %}
{% block algorithm_name %}Insertion Sort{% endblock %}
{% block algorithm_id %}insertion{% endblock %}

{% block algorithm_description %}
<p>Insertion Sort is an intuitive sorting algorithm that builds the final sorted array one item at a time, similar to how most people sort playing cards in their hands.</p>

<h4>Algorithm Steps:</h4>
<ol>
    <li>Start with the first element as a sorted portion of length one</li>
    <li>Take the next element and insert it into its correct position in the sorted portion</li>
    <li>To insert, shift all greater elements one position ahead</li>
    <li>Repeat until all elements are processed</li>
</ol>

<h4>Key Features:</h4>
<ul>
    <li>Efficient for small data sets</li>
    <li>Adaptive (runs faster on nearly sorted arrays)</li>
    <li>Stable sorting algorithm (maintains relative order of equal elements)</li>
    <li>In-place algorithm (uses constant extra space)</li>
    <li>Online (can sort a list as it receives it)</li>
</ul>
{% endblock %}

{% block complexity %}
    <td>Ω(n)</td>
    <td>θ(n²)</td>
    <td>O(n²)</td>
    <td>O(1)</td>
{% endblock %}

{% block algorithm_specific_js %}
<script>
// Custom colors for Insertion Sort
const COLORS = {
    default: '#8b5cf6',    // Violet for unsorted
    comparing: '#ef4444',  // Red for key element being compared
    shifting: '#facc15',   // Yellow for shifting elements
    sorted: '#ec4899'      // Pink for sorted elements
};

async function visualizeSort() {
    if (!isSorting) {
        try {
            isSorting = true;
            isPaused = false;
            currentSortingStep = 0;
            disableControls(true);
            
            const steps = [];
            const arrayCopy = [...array];
            const n = arrayCopy.length;
            
            // Initial state with first element sorted
            steps.push({
                array: [...arrayCopy],
                comparing: [],
                shifting: [],
                sorted: [0],
                keyElement: -1,
                positions: Array.from({length: n}, (_, i) => i)
            });
            
            for (let i = 1; i < n; i++) {
                const key = arrayCopy[i];
                let j = i - 1;
                
                // Show current key element
                steps.push({
                    array: [...arrayCopy],
                    comparing: [],
                    shifting: [],
                    sorted: Array.from({length: i}, (_, idx) => idx),
                    keyElement: i,
                    positions: Array.from({length: n}, (_, idx) => idx)
                });
                
                // Create temporary array for animation
                const tempArray = [...arrayCopy];
                const positions = Array.from({length: n}, (_, idx) => idx);
                
                while (j >= 0 && arrayCopy[j] > key) {
                    // Show comparison
                    steps.push({
                        array: [...tempArray],
                        comparing: [j],
                        shifting: [],
                        sorted: Array.from({length: i}, (_, idx) => idx),
                        keyElement: i,
                        positions: [...positions]
                    });
                    
                    // Shift element to the right
                    tempArray[j + 1] = tempArray[j];
                    positions[j + 1] = positions[j];
                    
                    steps.push({
                        array: [...tempArray],
                        comparing: [],
                        shifting: [j + 1],
                        sorted: Array.from({length: i}, (_, idx) => idx),
                        keyElement: i,
                        positions: [...positions]
                    });
                    
                    j--;
                }
                
                // Place key in correct position
                tempArray[j + 1] = key;
                positions[j + 1] = i;
                arrayCopy[j + 1] = key;
                
                // Show insertion
                steps.push({
                    array: [...tempArray],
                    comparing: [],
                    shifting: [],
                    sorted: Array.from({length: i + 1}, (_, idx) => idx),
                    keyElement: -1,
                    positions: [...positions]
                });
            }
            
            // Final state
            steps.push({
                array: [...arrayCopy],
                comparing: [],
                shifting: [],
                sorted: Array.from({length: n}, (_, i) => i),
                keyElement: -1,
                positions: Array.from({length: n}, (_, i) => i)
            });
            
            sortingSteps = steps;
            displayStep(steps[0]);
            updateTimeline();
            
        } catch (error) {
            console.error('Error during sorting:', error);
        }
    }
}

async function displayStep(step) {
    if (!step) return;
    
    const container = document.querySelector('.array-container');
    const maxValue = Math.max(...step.array);
    const containerHeight = container.clientHeight - 60;
    const barWidth = 28;  // Match the CSS width
    const margin = 2;     // Match the CSS margin
    const totalBarWidth = barWidth + (margin * 2);
    const totalWidth = step.array.length * totalBarWidth;
    const startX = (container.clientWidth - totalWidth) / 2;
    
    // First time setup of bars
    if (container.children.length === 0) {
        step.array.forEach((value, index) => {
            const barContainer = document.createElement('div');
            barContainer.className = 'bar-container';
            barContainer.style.left = `${startX + index * totalBarWidth}px`;
            
            const bar = document.createElement('div');
            bar.className = 'array-bar';
            
            const valueLabel = document.createElement('div');
            valueLabel.className = 'bar-value';
            valueLabel.textContent = value;
            
            const indexLabel = document.createElement('div');
            indexLabel.className = 'bar-index';
            indexLabel.textContent = index;
            
            bar.appendChild(valueLabel);
            barContainer.appendChild(bar);
            barContainer.appendChild(indexLabel);
            container.appendChild(barContainer);
        });
    }
    
    // Update all bars
    step.array.forEach((value, index) => {
        const barContainer = container.children[step.positions[index]];
        const bar = barContainer.querySelector('.array-bar');
        const valueLabel = bar.querySelector('.bar-value');
        
        // Update position and height
        const targetX = startX + index * totalBarWidth;
        barContainer.style.left = `${targetX}px`;
        const height = Math.max(20, (value / maxValue) * containerHeight);
        bar.style.height = `${height}px`;
        valueLabel.textContent = value;
        
        // Set color based on state
        if (index === step.keyElement) {
            bar.style.backgroundColor = COLORS.comparing;
            // Lift the key element slightly
            barContainer.style.transform = 'translateY(-20px)';
        } else if (step.comparing && step.comparing.includes(index)) {
            bar.style.backgroundColor = COLORS.comparing;
            barContainer.style.transform = 'none';
        } else if (step.shifting && step.shifting.includes(index)) {
            bar.style.backgroundColor = COLORS.shifting;
            barContainer.style.transform = 'none';
        } else if (step.sorted && step.sorted.includes(index)) {
            bar.style.backgroundColor = COLORS.sorted;
            barContainer.style.transform = 'none';
        } else {
            bar.style.backgroundColor = COLORS.default;
            barContainer.style.transform = 'none';
        }
    });
    
    // Handle animation delay
    if (step.comparing.length > 0 || step.shifting.length > 0 || step.keyElement !== -1) {
        await new Promise(resolve => setTimeout(resolve, BASE_ANIMATION_SPEED * getSpeedMultiplier()));
    }
}
</script>
{% endblock %}

{% block how_it_works %}
<div class="how-it-works">
    <h3>How Insertion Sort Works</h3>
    <p>Insertion Sort is a simple sorting algorithm that builds the final sorted array one item at a time. It works similar to how you sort playing cards in your hands.</p>
    
    <div class="steps">
        <h4>Algorithm Steps:</h4>
        <ol>
            <li>Start with the first element as a sorted portion of length one</li>
            <li>Take the next element and compare it with the sorted portion</li>
            <li>Insert the element at its correct position in the sorted portion</li>
            <li>Shift the greater elements one position ahead to make space</li>
            <li>Repeat steps 2-4 until all elements are processed</li>
        </ol>
    </div>
    
    <div class="complexity">
        <h4>Time Complexity:</h4>
        <ul>
            <li>Best Case: O(n) - When array is already sorted</li>
            <li>Average Case: O(n²)</li>
            <li>Worst Case: O(n²) - When array is reverse sorted</li>
        </ul>
        
        <h4>Space Complexity:</h4>
        <ul>
            <li>O(1) - Only uses a constant amount of extra space</li>
        </ul>
        
        <h4>Properties:</h4>
        <ul>
            <li>Stable: Yes</li>
            <li>In-place: Yes</li>
            <li>Adaptive: Yes (performs better on partially sorted arrays)</li>
        </ul>
    </div>
</div>
{% endblock %}
