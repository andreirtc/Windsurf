{% extends "sorting/base_sorting.html" %}

{% block breadcrumb_name %}Merge Sort{% endblock %}
{% block algorithm_name %}Merge Sort{% endblock %}
{% block algorithm_id %}merge{% endblock %}

{% block algorithm_description %}
<p>Merge Sort is a divide-and-conquer algorithm that recursively breaks down a problem into smaller, more manageable subproblems until they become simple enough to solve directly.</p>

<h4>Algorithm Steps:</h4>
<ol>
    <li>Divide the unsorted array into two halves</li>
    <li>Recursively sort the two halves</li>
    <li>Merge the sorted halves:
        <ul>
            <li>Create a temporary array for merging</li>
            <li>Compare elements from both halves</li>
            <li>Place the smaller element in the temporary array</li>
            <li>Copy remaining elements from non-empty half</li>
        </ul>
    </li>
    <li>Continue until the entire array is sorted</li>
</ol>

<h4>Key Features:</h4>
<ul>
    <li>Stable sorting algorithm</li>
    <li>Not in-place (requires extra space)</li>
    <li>Predictable performance (always O(n log n))</li>
    <li>Parallelizable (can be efficiently parallelized)</li>
    <li>External sorting (good for sorting data that doesn't fit in memory)</li>
</ul>
{% endblock %}

{% block complexity %}
    <td>Ω(n log n)</td>
    <td>θ(n log n)</td>
    <td>O(n log n)</td>
    <td>O(n)</td>
{% endblock %}

{% block algorithm_specific_js %}
<script>
// Custom colors for Merge Sort
const COLORS = {
    default: '#8b5cf6',    // Violet for unsorted
    comparing: '#ef4444',  // Red for comparing elements
    merging: '#facc15',    // Yellow for merging
    sorted: '#ec4899',     // Pink for sorted
    subarray: '#22c55e'    // Green for showing subarrays
};

async function visualizeSort() {
    if (!isSorting) {
        try {
            isSorting = true;
            isPaused = false;
            currentSortingStep = 0;
            disableControls(true);
            
            const steps = [];
            const arrayCopy = [...array];
            
            // Initial state
            steps.push({
                array: [...arrayCopy],
                comparing: [],
                merging: [],
                sorted: [],
                subarrays: [],
                depth: new Array(arrayCopy.length).fill(0)
            });
            
            async function mergeSort(start, end, currentDepth) {
                if (start < end) {
                    const mid = Math.floor((start + end) / 2);
                    
                    // Show division of array
                    const depth = new Array(arrayCopy.length).fill(0);
                    for (let i = start; i <= end; i++) {
                        depth[i] = currentDepth;
                    }
                    
                    steps.push({
                        array: [...arrayCopy],
                        comparing: [],
                        merging: [],
                        sorted: [],
                        subarrays: [[start, mid], [mid + 1, end]],
                        depth: [...depth]
                    });
                    
                    // Recursively sort left and right halves
                    await mergeSort(start, mid, currentDepth + 1);
                    await mergeSort(mid + 1, end, currentDepth + 1);
                    
                    // Merge the sorted halves
                    await merge(start, mid, end, currentDepth);
                }
            }
            
            async function merge(start, mid, end, currentDepth) {
                const leftArray = arrayCopy.slice(start, mid + 1);
                const rightArray = arrayCopy.slice(mid + 1, end + 1);
                
                let i = 0;
                let j = 0;
                let k = start;
                
                const depth = new Array(arrayCopy.length).fill(0);
                for (let idx = start; idx <= end; idx++) {
                    depth[idx] = currentDepth;
                }
                
                // Show subarrays being merged
                steps.push({
                    array: [...arrayCopy],
                    comparing: [],
                    merging: [],
                    sorted: [],
                    subarrays: [[start, mid], [mid + 1, end]],
                    depth: [...depth]
                });
                
                while (i < leftArray.length && j < rightArray.length) {
                    // Show comparison
                    steps.push({
                        array: [...arrayCopy],
                        comparing: [start + i, mid + 1 + j],
                        merging: [],
                        sorted: [],
                        subarrays: [[start, mid], [mid + 1, end]],
                        depth: [...depth]
                    });
                    
                    if (leftArray[i] <= rightArray[j]) {
                        arrayCopy[k] = leftArray[i];
                        steps.push({
                            array: [...arrayCopy],
                            comparing: [],
                            merging: [k],
                            sorted: [],
                            subarrays: [[start, mid], [mid + 1, end]],
                            depth: [...depth]
                        });
                        i++;
                    } else {
                        arrayCopy[k] = rightArray[j];
                        steps.push({
                            array: [...arrayCopy],
                            comparing: [],
                            merging: [k],
                            sorted: [],
                            subarrays: [[start, mid], [mid + 1, end]],
                            depth: [...depth]
                        });
                        j++;
                    }
                    k++;
                }
                
                while (i < leftArray.length) {
                    arrayCopy[k] = leftArray[i];
                    steps.push({
                        array: [...arrayCopy],
                        comparing: [],
                        merging: [k],
                        sorted: [],
                        subarrays: [[start, mid], [mid + 1, end]],
                        depth: [...depth]
                    });
                    i++;
                    k++;
                }
                
                while (j < rightArray.length) {
                    arrayCopy[k] = rightArray[j];
                    steps.push({
                        array: [...arrayCopy],
                        comparing: [],
                        merging: [k],
                        sorted: [],
                        subarrays: [[start, mid], [mid + 1, end]],
                        depth: [...depth]
                    });
                    j++;
                    k++;
                }
                
                // Show sorted subarray
                steps.push({
                    array: [...arrayCopy],
                    comparing: [],
                    merging: [],
                    sorted: Array.from({length: end - start + 1}, (_, i) => start + i),
                    subarrays: [],
                    depth: new Array(arrayCopy.length).fill(0)
                });
            }
            
            // Start merge sort
            await mergeSort(0, arrayCopy.length - 1, 0);
            
            // Final state - all sorted
            steps.push({
                array: [...arrayCopy],
                comparing: [],
                merging: [],
                sorted: Array.from({length: arrayCopy.length}, (_, i) => i),
                subarrays: [],
                depth: new Array(arrayCopy.length).fill(0)
            });
            
            sortingSteps = steps;
            displayStep(steps[0]);
            updateTimeline();
            
        } catch (error) {
            console.error('Error during sorting:', error);
        }
    }
}

async function displayStep(step) {
    if (!step) return;
    
    const container = document.querySelector('.array-container');
    const maxValue = Math.max(...step.array);
    const containerHeight = container.clientHeight - 60;
    const barWidth = 28;  // Match the CSS width
    const margin = 2;     // Match the CSS margin
    const totalBarWidth = barWidth + (margin * 2);
    const totalWidth = step.array.length * totalBarWidth;
    const startX = (container.clientWidth - totalWidth) / 2;
    const depthOffset = 30;  // Pixels to move down for each depth level
    
    // First time setup of bars
    if (container.children.length === 0) {
        step.array.forEach((value, index) => {
            const barContainer = document.createElement('div');
            barContainer.className = 'bar-container';
            barContainer.style.left = `${startX + index * totalBarWidth}px`;
            
            const bar = document.createElement('div');
            bar.className = 'array-bar';
            
            const valueLabel = document.createElement('div');
            valueLabel.className = 'bar-value';
            valueLabel.textContent = value;
            
            const indexLabel = document.createElement('div');
            indexLabel.className = 'bar-index';
            indexLabel.textContent = index;
            
            bar.appendChild(valueLabel);
            barContainer.appendChild(bar);
            barContainer.appendChild(indexLabel);
            container.appendChild(barContainer);
        });
    }
    
    // Update all bars
    step.array.forEach((value, index) => {
        const barContainer = container.children[index];
        const bar = barContainer.querySelector('.array-bar');
        const valueLabel = bar.querySelector('.bar-value');
        
        // Update position and height
        barContainer.style.left = `${startX + index * totalBarWidth}px`;
        const height = Math.max(20, (value / maxValue) * containerHeight);
        bar.style.height = `${height}px`;
        valueLabel.textContent = value;
        
        // Apply vertical offset based on depth
        const translateY = step.depth[index] * depthOffset;
        barContainer.style.transform = `translateY(${translateY}px)`;
        
        // Set color based on state
        if (step.comparing && step.comparing.includes(index)) {
            bar.style.backgroundColor = COLORS.comparing;
        } else if (step.merging && step.merging.includes(index)) {
            bar.style.backgroundColor = COLORS.merging;
        } else if (step.sorted && step.sorted.includes(index)) {
            bar.style.backgroundColor = COLORS.sorted;
        } else if (step.subarrays && step.subarrays.some(([start, end]) => index >= start && index <= end)) {
            bar.style.backgroundColor = COLORS.subarray;
        } else {
            bar.style.backgroundColor = COLORS.default;
        }
    });
    
    // Handle animation delay
    if (step.comparing || step.merging) {
        await new Promise(resolve => setTimeout(resolve, BASE_ANIMATION_SPEED * getSpeedMultiplier()));
    }
}
</script>
{% endblock %}

{% block how_it_works %}
<div class="how-it-works">
    <h3>How Merge Sort Works</h3>
    <p>Merge Sort is a divide-and-conquer algorithm that recursively breaks down a problem into smaller, more manageable subproblems until they become simple enough to solve directly.</p>
    
    <div class="steps">
        <h4>Algorithm Steps:</h4>
        <ol>
            <li>Divide the unsorted array into two halves</li>
            <li>Recursively sort the two halves</li>
            <li>Merge the sorted halves to produce a single sorted array:
                <ul>
                    <li>Create a temporary array to store merged result</li>
                    <li>Compare elements from both halves</li>
                    <li>Place the smaller element in the temporary array</li>
                    <li>Copy remaining elements from non-empty half</li>
                </ul>
            </li>
            <li>Continue this process until the entire array is sorted</li>
        </ol>
    </div>
    
    <div class="complexity">
        <h4>Time Complexity:</h4>
        <ul>
            <li>Best Case: O(n log n)</li>
            <li>Average Case: O(n log n)</li>
            <li>Worst Case: O(n log n)</li>
        </ul>
        
        <h4>Space Complexity:</h4>
        <ul>
            <li>O(n) - Requires additional space proportional to input size</li>
        </ul>
        
        <h4>Properties:</h4>
        <ul>
            <li>Stable: Yes</li>
            <li>In-place: No</li>
            <li>Adaptive: No</li>
            <li>Parallelizable: Yes (can be efficiently parallelized)</li>
        </ul>
    </div>
</div>
{% endblock %}
